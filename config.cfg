#///    \file
#///    CONFIG_CFG
#///
#///    \Author: Ayesha Afzal <ayesha.afzal@fau.de>
#///    \Copyright Â© 2023 HPC, FAU Erlangen-Nuremberg. All rights reserved.
#///

# CLUSTER MODEL: Basic characteristics and resource allocation 
heteregeneous = 0                     # a bool flag to enable or disable the heterogenous system (1: enabled, 0: disabled)
waitio_mode = socket                  # mode of the WaitIO MPI library (socket, file or hybrid)
comm_model = 0                        # performance model for communication (0: LogGP, 1: HOCKNEY)
number_of_timesteps = 5               # numer of iterations of the program
dim_x = 20000                         # Problem size for first system
dim_y = 20000
dim_z = 0
secondary_dim_x = 20000               # Problem size for second system
secondary_dim_y = 20000
secondary_dim_z = 0
task_per_node = 12                    # number of running processes on one node of first system
number_of_processes = 48              # total number of running processes on first system
secondary_task_per_node = 12          # number of running processes on one node of second system
secondary_number_of_processes = 48    # total number of running processes on second system

# APPLICATION MODEL
benchmark_kernel = STREAM     	      # name of the kernel used in the program
kernel_mode = FILE                    # mode of the kernel (FILE, SRC, LBL, COMP)

# FIRST SYSTEM: NODE MODEL and compiler options
micro_architecture = IcelakeSP_Platinum-8360Y # name of the YAML machine file for the first system 
FP_instructions_per_cycle = 4         # Floating Point instructions per cycle for the first system's processor
compiler-flags = -Kfast -DTOFU        # STD and SIMD optimizations for the first system (-03 -xCORE-AVX512 -qopt-zmm-usage=high, -03 -xHost -xAVX, -Kfast -DTOFU)
pmodel = ECM                          # performance model for computation for the first system (ECM, Roofline)
vvv = 0                               # verbose output for the first system (0: disabled, 1: enabled)
cache-predictor = LC                  # cache prediction for the first system (LC, paysim)
penalty = 0                           # penalty in nanoseconds for the first system, used only in LBL or COMP mode

# SECOND SYSTEM: NODE MODEL and compiler options
secondary_micro_architecture = IcelakeSP_Platinum-8360Y # name of the YAML machine file for the second system 
secondary_FP_instructions_per_cycle = 4                 # Floating Point instructions per cycle for the second system's processor
secondary_compiler_flags = -03                          # STD and SIMD optimizations for the second system (-03 -xCORE-AVX512 -qopt-zmm-usage=high, -03 -xHost -xAVX, -Kfast -DTOFU)
secondary_pmodel = ECM                                  # performance model for computation for the second system (ECM, Roofline)
decondary_vvv = 0                                       # verbose output for the second system (0: disabled, 1: enabled)
secondary_cache_predictor = LC                          # cache prediction for the second system (LC, paysim)
secondary_penalty = 0                                   # penalty in nanoseconds for the second system, used only in LBL or COMP mode

# ROOFLILE MODEL PARAMETERS
FLOPs_per_iteration = 2               # number of flops in one iteration
R_streams = 3                         # number of read streams
W_streams = 1                         # number of write streams
datasize_in_GB = 2.98                 # number of array elements * (R_streams + W_streams) * size of datatype

# DELAY INJECTION MODE
delay = 0                             # delay injection (0: disabled, 1: enabled)
noise_intensity = 20                  # intensity of delay as a  multiple of computation time of one iteration                                 
delay_rank = 4                        # process rank of the injected delay
delay_timestep = 5                    # iteration for the occurrence the injected delay

# NOISE INJECTION MODE
noise = 0                             # noise injection (0: disabled, 1: enabled)
noise_intensity = 5000                # intensity of random noise, i.e., rand() % noise_intensity                                
noise_start_timestep = 1              # starting iteration for the injected noise
noise_stop_timestep = 50              # ending iteration for the injected noise

# OUTPUT
filename = DisCostiC.csv			        # output file name that contain details for debug purpose
vizfilename = DisCostiC			          # output file name that contains all time rank tracing data for visulization with Drawviz tool
chromevizfilename = DisCostiC	        # output file name that contains all time rank tracing data for visulization with Chrome tracing browser
Verbose = 0							              # verbose output (0: disabled, 1: enabled)
batchmode = 0						              # batchmode (0: disable, i.e., printing performance for each rank, 1: enabled, i.e., never print detailed all rank info)
timeunit_conv = 1;                    # time multiplier for conversation from baseline unit of nanoseconds to some other unit

